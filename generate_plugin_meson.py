#!/usr/bin/env python3
import argparse, os, subprocess, glob, shutil

def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument('--headers', nargs='+', required=True)
    p.add_argument('--plugin-dir', required=True)
    p.add_argument('--lib-name', required=True)
    p.add_argument('--split', action='store_true')
    p.add_argument('--registry-header')
    p.add_argument('--registry-instance')
    p.add_argument('--module-name-base')
    p.add_argument('--parser-exe', default='gnuradio_4_0_parse_registrations')
    return p.parse_args()

def merge_inputs(pattern, output_file):
    files = sorted(glob.glob(pattern))
    if not files:
        return
    with open(output_file, 'w') as fout:
        for fname in files:
            with open(fname) as fin:
                fout.write(fin.read())

def main():
    args = parse_args()
    plugindir = args.plugin_dir
    plugingendir = os.path.join(plugindir,'generated')
    os.makedirs(plugindir, exist_ok=True)
    os.makedirs(plugingendir, exist_ok=True)

    parser_flags = []
    if args.split:
        parser_flags.append('--split')
    if args.registry_header:
        parser_flags += ['--registry-header', args.registry_header]
    if args.registry_instance:
        parser_flags += ['--registry-instance', args.registry_instance]

    generated_cpp = []

    for hdr in args.headers:
        basename = os.path.splitext(os.path.basename(hdr))[0]
        glob_cpp = os.path.join(plugingendir, f"{basename}*.cpp")
        glob_hppin = os.path.join(plugingendir, f"{basename}*.hpp.in")

        # Remove old generated files for this header
        for f in glob.glob(glob_cpp) + glob.glob(glob_hppin):
            os.remove(f)

        # Always regenerate for safety
        cmd = [args.parser_exe, hdr, plugingendir] + parser_flags
        print(f"Running: {' '.join(cmd)}")
        res = subprocess.run(cmd, capture_output=True, text=True)
        print(f"stdout: {res.stdout}")
        if res.returncode != 0:
            print(f"stderr: {res.stderr}")
            raise RuntimeError(f"Error running {args.parser_exe} on {hdr}")

        files = glob.glob(glob_cpp)
        if not files:
            # Create dummy
            dummy_cpp = os.path.join(plugingendir, f"dummy_{basename}.cpp")
            with open(dummy_cpp, 'w') as f:
                f.write(f"// No macros or expansions found for '{basename}'\n")
            files = [dummy_cpp]
        generated_cpp += files

    # Merge _declarations.hpp.in and _raw_calls.hpp.in into .hpp
    decl_hppin = os.path.join(plugingendir, '*_declarations.hpp.in')
    rawcalls_hppin = os.path.join(plugingendir, '*_raw_calls.hpp.in')
    decl_hpp = os.path.join(plugingendir, 'declarations.hpp')
    rawcalls_hpp = os.path.join(plugingendir, 'raw_calls.hpp')
    merge_inputs(decl_hppin, decl_hpp)
    merge_inputs(rawcalls_hppin, rawcalls_hpp)

    # Write a complete meson.build file in the plugin directory
    mesonfile = os.path.join(plugindir, 'meson.build')
    with open(mesonfile, 'w') as fout:
        fout.write("# Auto-generated by generate_plugin_meson.py\n")
        fout.write("incdir = include_directories(['../include','../../../'])\n")
        fout.write("generated_cpp = files(\n")
        for f in generated_cpp:
            fout.write(f"  'generated/{os.path.basename(f)}',\n")
        fout.write(    f"  'generated/integrator.cpp'")
        fout.write(")\n\n")
        fout.write("plugin_libname = '{}'\n".format(args.lib_name))
        fout.write("my_lib_shared = shared_library(plugin_libname + 'Shared', generated_cpp, include_directories: incdir, dependencies: [gr4_dep], link_args: ['/usr/local/lib/libgnuradio-blocklib-core.so'], install: true)\n")
        fout.write("my_lib_static = static_library(plugin_libname + 'Static', generated_cpp, include_directories: incdir, dependencies: [gr4_dep], install: true)\n")
        



    print(f"Wrote {mesonfile}")

if __name__ == '__main__':
    main()
